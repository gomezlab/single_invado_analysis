function [corr_img, x_shift, y_shift] = kr_fretF(aa1, aa2)% kr_fretF. m -- K-means clustering for registering FRET image pairs% This function aligns and ratios two input images with subpixel precision% functions needed:  contra.m kmeanst.m subpixShift.m subalign.m%% Author:   Feimo Shen%c=double(c);% cfpShade=imread('cfpShade.tif');% fretShade=imread('fretShade.tif');% cfpShade(cfpShade==0)=1;% fretShade(fretShade==0)=1;last_slim1=[0.0157;0.0196];last_slim2=last_slim1;% cfp Image%aa1=imread(fname1,'tif');%aa2=imread(fname2,'tif');% shade correct:% aa1=uint16(double(aa1)*1000./double(cfpShade));% aa2=uint16(double(aa2)*1000./double(fretShade));% thresholding based on clustering:% contrast enhancing:if 0    slim1=round(stretchlim(aa1)*100000)/100000; % round to patch another    slim2=round(stretchlim(aa2)*100000)/100000; % glitch in MATLAB    if (slim1==[0;1] | slim2==[0;1])% patching a glitch in MATLAB        lhin1=last_slim1;        lhin2=last_slim2;    else        lhin1=slim1;        lhin2=slim2;        last_slim1=slim1;        last_slim2=slim2;    end    fv1=imadjust(aa1,lhin1,[0 1]);    fv2=imadjust(aa2,lhin2,[0 1]);    fv1=double(fv1);    fv2=double(fv2);    options=zeros(1,15);    options(2)=5;    options(3)=1;    options(14)=120;    [centers1,op1,post1,error1]=kmeanst(c,fv1(:),options);    [centers2,op2,post2,error2]=kmeanst(c,fv2(:),options);    centers1    centers2    [id,jd]=size(aa1);    % assign correct brightness    [gs, ind]=sort(centers1);    picc1=zeros(id,jd);    for i=1:length(c)        pic1{i}=reshape(post1(:,ind(i)), id,jd);        picc1(pic1{i}==1)=i-1;    end    backgnd1=reshape(post1(:,ind(1)), id,jd);    [gs, ind]=sort(centers2);    picc2=zeros(id,jd);    for i=1:length(c)        pic2{i}=reshape(post2(:,ind(i)), id,jd);        picc2(pic2{i}==1)=i-1;    end    backgnd2=reshape(post2(:,ind(1)), id,jd);    picc1(picc1>0)=255;    picc2(picc2>0)=255;    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    % background subtraction    aa1=double(aa1);    back1=aa1.*backgnd1;    backavg1=sum(sum(back1)) / sum(sum(backgnd1));    aa1=aa1-backavg1;    aa1(aa1<=0)=0;    aa2=double(aa2);    back2=aa2.*backgnd2;    backavg2=sum(sum(back2)) / sum(sum(backgnd2));    aa2=aa2-backavg2;    aa2(aa2<=0)=0;    %%%%%%%%%%%%%%%%%%%%%%%%%end% registration based on cross correlationim1a_flag=0;im2a_flag=0;correlation=normxcorr2(aa1, aa2);[xoffsetsub,yoffsetsub]=subpixShift(correlation);% shift:xoffset=floor(xoffsetsub);yoffset=floor(yoffsetsub);% whole pixel shift first:se  = translate(strel(1), [yoffset xoffset]);aa2 = imdilate(uint16(aa2),se);% then subpixel shift:aa2 = subalign(aa2,xoffsetsub-xoffset,yoffsetsub-yoffset);corr_img = aa2;x_shift  = xoffsetsub + xoffset;y_shift  = yoffsetsub + yoffset;% divide and mask using CFP image:%         picc1(picc1>1)=1;%         ima1d=aa1;%         ima1d(ima1d==0)=1;%         ratioed=uint16( (double(aa2)*1000)./ima1d.*picc1 );%         fnameOut=sprintf('ratioed%i%s',fd(ff),fname);%         imwrite(ratioed,fnameOut,'tif','Compression','none');